\documentclass[acmsmall, nonacm, screen]{acmart}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}

\newif\ifdraft\draftfalse

\newcommand{\outline}[1]{
  \ifdraft
  {\color{gray}{#1}}
  \fi
}

\newcommand{\ifThenElse}[3]{\textsf{if}~#1~\textsf{then}~#2~\textsf{else}~#3}
\newcommand{\letIn}[3]{\textsf{let}~#1 = #2~\textsf{in}~#3}
\newcommand{\shift}[2]{\textsf{shift}~#1~\textsf{in}~#2}
\newcommand{\reset}[1]{\langle #1 \rangle}
\newcommand{\lambdaE}[2]{\lambda #1.\, #2}
\newcommand{\just}[1]{\textsf{Just}~#1}
\newcommand{\nothing}{\textsf{Nothing}}

\lstset{ %
  backgroundcolor=\color{white},
  commentstyle=\color{ACMGreen},
  keywordstyle=\color{ACMDarkBlue},
  stringstyle=\color{ACMPurple},
  basicstyle=\ttfamily
}

\lstdefinestyle{hs}{
  language=Haskell
}

\lstdefinestyle{rkt}{
  language=lisp,
  deletekeywords={get},
  morekeywords={define},
  literate=*{(}{{\textcolor{gray}{(}}}{1}
    {)}{{\textcolor{gray}{)}}}{1}
}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}


\acmBooktitle{}

\begin{document}

\title{Delimited Continuations and Monads}
\subtitle{A Comparison of Programming Abstractions}
\titlenote{
  This report was compiled for part of the University of Pennsylvania's WPE-II Exam. The
  accompanying talk is available on the author's website.
}

\author{Harrison Goldstein}
\email{hgo@seas.upenn.edu}
\orcid{0000−0001−9631−1169}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia, PA}
  \country{USA}
}

\renewcommand{\shortauthors}{Goldstein}

\begin{abstract}
  Around the year 1990, two programming abstractions were introduced: {\em delimited
  continuations} and {\em monads}. \citet{danvy1989functional} explored delimited continuations
  as a principled way of manipulating program contexts as first-class functions.
  \citet{wadler1990comprehending} popularized monads as a tool for simulating effects in a pure
  language. Though they seem to have little to do with one-another, delimited continuations and
  monads actually have a lot in common: they can solve many of the same programming problems, and
  their meta-theories are surprisingly compatible. This report re-contextualizes those early 90's
  papers and explores the commonalities between monads and delimited continuations.
\end{abstract}

\maketitle

\section{Introduction} \label{sec:introduction}
Programming languages research focuses heavily on abstractions. Abstractions enable programmers
to write code that is succinct and clear while hiding implementation details. Consider the
following programs that appear to be stateful:
\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \begin{lstlisting}[style=rkt]
  (define (program)
    (let ([i (get)])
      (put (+ i 3))
      (let ([j (get)])
        (put (* j 7))
        (get))))

  (eval-state program 3) ; 42
  \end{lstlisting}
  \label{fig:racket-state}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \begin{lstlisting}[style=hs]
  program = do
    i <- get
    put (i + 3)
    j <- get
    put (j * 7)
    get

  evalState program 3 -- 42
  \end{lstlisting}
  \label{fig:hs-state}
\end{subfigure}
\Description[State Abstraction]{Code for manipulating state.}
\label{fig:stateful-comps}
\end{figure}
\noindent Perhaps surprisingly, both of these programs are ``purely'' functional---they do not
use references or other imperative features. The illusion of state is created by underlying
abstractions that allow the programmer to think in terms of changing state without sacrificing
the advantages of purity.

The first snippet, written in Racket, uses {\em delimited continuations} to implement a stateful
API. A continuation is a first-class representation of the "rest" of a computation. For example,
when evaluating the sub-expression ``$x < 3$'' in
\[ \ifThenElse{x < 3}{10}{20}, \]
the remaining {\em context} is
\[ \ifThenElse{\_}{10}{20}, \]
and the continuation, $k$, is
\[ k = \lambdaE{b}{\ifThenElse{b}{10}{20}}. \]
The continuation captures the context as a function. In {\em A Functional Abstraction of Typed
Contexts}, \citet{danvy1989functional} present two operators for manipulating continuations: {\em
shift} (written ``$\shift{k}{e}$'') and {\em reset} (written ``$\reset{e}$''). Reset delimits the
scope of the current context---in the example above, we implicitly wrap the whole expression in a
reset. The expression ``$\shift{k}{e}$''captures the current context as a continuation, $k$, and
then executes $e$ in a fresh context. We can use shift and reset to extract the continuation from
above:
\begin{align*}
  & \reset{\ifThenElse{(\shift{k}{k~(x < 3)})}{10}{20}} \\
  \rightarrow\ & \letIn{k}{(\lambdaE{b}{\ifThenElse{b}{10}{20}})}{k~(x < 3)}
\end{align*}
Reset delimits the context, in this case the whole ``$\textsf{if}$'' expression, and shift
packages the continuation into $k$. In this example the shift body just applies $k$, so nothing
has changed---the result will be the same as the original expression. But the shift body can be
anything. In particular, if $k$ is not used at all
\[ \reset{\ifThenElse{(\shift{k}{x < 3})}{10}{20}} \]
the result is essentially an {\em exception}: the ``$\textsf{if}$'' is thrown away and the result
of the computation is just $x < 3$. Clever uses of delimited continuations like this can be used
to build up complex control flow including the state abstraction from our original example.

The second snippet simulates stateful computations using a {\em monad} in Haskell. Monads were
introduced to the programming languages literature by \citet{moggi1991notions}, but they were
popularized by \citeauthor{wadler1990comprehending} in {\em Comprehending
Monads}~\cite{wadler1990comprehending}. As a programming abstraction, monads generalize the
well-known idea of list comprehensions:
\[
  [ (x,\,y) \mid x \leftarrow [1,\, 2] ;\ y \leftarrow [3,\, 4] ]^{\textsf{List}}
\]
This expression results in the Cartesian product of lists ``$[1,\, 2]$'' and ``$[3,\, 4]$.''
Wadler observed that comprehension syntax can be to program with any monad (not just
$\textsf{List}$):
\[
  [ y \mid x \leftarrow \textsf{thisMightFail}~() ;\ y \leftarrow \textsf{thisMightFailToo}~{x} ]^{\textsf{Maybe}}
\]
This monad, usually called $\textsf{Maybe}$, implements a form of exceptions: if either of the
provided computations fail, the result of comprehension will be $\nothing$, otherwise the result
will be the value stored in $y$. There are dozens of monads that programmers use in practice,
each of which gives a different interpretation of comprehension syntax. One such monad,
$\textsf{State}$, can be used to implement our running example.

It is not immediately clear that manipulating continuations has anything to do with interpreting
comprehension syntax. One would be forgiven for assuming that these ideas are largely orthogonal.
But we have already seen that that delimited continuations and monads can be used to implement
some of the same design patterns. Could there be more overlap? Yes! It turns out that that are
many programming techniques, including state, exceptions, non-determinism, and more, that can be
implemented using either delimited continuations or monads. Furthermore, continuations actually
form a monad, and \citeauthor{wadler1990comprehending} shows that this fact can be exploited to
to recover results from \citeauthor{danvy1989functional}.

In this report I make three contributions, after a brief discussion of common notation
(\S~\ref{sec:notation}):
\begin{itemize}
  \item I summarize and re-contextualize two influential papers: {\em A Functional Abstraction of
  Typed Contexts} by \citeauthor{danvy1989functional} (\S~\ref{sec:danvy}) and {\em Comprehending
  Monads} by \citeauthor{wadler1990comprehending} (\S~\ref{sec:wadler}).\footnote{This is a
  requirement of the WPE-II exam, but I hope that reformulating these results will still be
  instructive.}
  \item I show the many design patterns that can be implemented equally well by both delimited
  continuations and monads, establishing a close relationship between the two language features
  (\S~\ref{sec:patterns}).
  \item I explore the {\em continuation monad} and show that by performing a monad-agnostic
  transformation given by \citeauthor{wadler1990comprehending} we can recover the ``extended
  continuation passing style'' transformation presented by \citeauthor{danvy1989functional}
  (\S~\ref{sec:contmonad}).
\end{itemize}
I conclude with some remarks on the broader context in which these abstractions exist
(\S~\ref{sec:conclusion}).

\section{Notes on Notation} \label{sec:notation}

\outline{
\begin{itemize}
  \item Racket and Haskell for examples
  \item Delimited Continuations: {\tt shift k in e} vs $\xi k.\,e$, {\tt reset e} vs $\langle e \rangle$
  \item Monads: join vs. bind vs. comprehensions.
    $x \leftarrow e_1 ;\!; e_2 \equiv \textsf{bind}~e_1~(\lambda x.\, e_2)$
  \item Assume a base, simply-typed lambda calculus
\end{itemize}
}

\section{{\em A Functional Abstraction of Typed Contexts}} \label{sec:danvy}

\section{{\em Comprehending Monads}} \label{sec:wadler}

\section{Common Design Patterns} \label{sec:patterns}

\section{The Continuation Monad} \label{sec:contmonad}

\section{Conclusion} \label{sec:conclusion}

\begin{acks}
\end{acks}

\bibliography{references}
\bibliographystyle{plainnat}

\end{document}

% \begin{quote}
%   [In some languages,] it may be possible to jump out of an expression and then later jump back
%   into it again and resume the process of evaluation. Continuations are sufficiently powerful to
%   deal with such a situation. (This could not be taken to imply approval of jumps back into
%   expressions as a language design feature—but if a language can specify something, however odd,
%   the method used to give its formal semantics must be powerful enough to describe it.)
%   \cite{strachey2000continuations}
% \end{quote}
