\documentclass[acmsmall, nonacm]{acmart}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{color}
\usepackage{xcolor}

\newcommand{\outline}[1]{{\color{gray}{#1}}}
\newcommand{\ifThenElse}[3]{\textsf{if}~#1~\textsf{then}~#2~\textsf{else}~#3}
\newcommand{\letIn}[3]{\textsf{let}~#1 = #2~\textsf{in}~#3}
\newcommand{\shift}[2]{\textsf{shift}~#1~\textsf{in}~#2}
\newcommand{\reset}[1]{\langle #1 \rangle}
\newcommand{\lambdaE}[2]{\lambda #1.\, #2}
\newcommand{\just}[1]{\textsf{Just}~#1}
\newcommand{\nothing}{\textsf{Nothing}}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},
  commentstyle=\color{mygreen},
  keywordstyle=\color{blue},
  stringstyle=\color{mymauve},
  basicstyle=\ttfamily
}

\lstdefinestyle{hs}{
  language=Haskell
}

\lstdefinestyle{rkt}{
  language=lisp,
  deletekeywords={get},
  morekeywords={define},
  literate=*{(}{{\textcolor{gray}{(}}}{1}
    {)}{{\textcolor{gray}{)}}}{1}
}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}


\acmBooktitle{}

\begin{document}

\title{Delimited Continuations and Monads}
\subtitle{A Comparison of Programming Abstractions}
\titlenote{
  This report was compiled for part of the University of Pennsylvania's WPE-II Exam. The
  accompanying talk is available on the author's website.
}

\author{Harrison Goldstein}
\email{hgo@seas.upenn.edu}
\orcid{0000−0001−9631−1169}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia, PA}
  \country{USA}
}

\renewcommand{\shortauthors}{Goldstein}

\begin{abstract}
  The control operators {\tt shift} and {\tt reset} are rooted in the well-studied field of {\em
  continuations}. The functions {\tt return} and {\tt join} define the rich structure of {\em
  monads}. On their face, these abstractions have very little to do with one another, but beneath
  the surface they are actually closely related. In this report I explore seminal work on
  continuations and monads as programming abstractions and show how both enable pure programming
  in a direct style. I show an informal bijection: monads can implement control operators, and
  control operators can implement a number of common monads. Finally, I connect the meta-theories
  of continuations and monads and detail their uses in denotational semantics.
\end{abstract}

\maketitle

\section{Introduction} \label{sec:introduction}
Programmers need to express their ideas as succinctly and clearly as possible. Such clarity often
relies on abstractions that allow complex control flow to be written in a {\em direct style}.
Consider the following programs that appear to be stateful:
\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \begin{lstlisting}[style=rkt]
  (define (program)
    (let ([i (get)])
      (put (+ i 3))
      (let ([j (get)])
        (put (* j 7))
        (get))))

  (eval-state program 3) ; 42
  \end{lstlisting}
  \label{fig:racket-state}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \begin{lstlisting}[style=hs]
  program = do
    i <- get
    put (i + 3)
    j <- get
    put (j * 7)
    get

  evalState program 3 -- 42
  \end{lstlisting}
  \label{fig:hs-state}
\end{subfigure}
\Description[State Abstraction]{Code for manipulating state.}
\label{fig:stateful-comps}
\end{figure}
\noindent Neither of these programs actually use references or other imperative
features---they're both ``purely'' functional. The abstractions underlying {\tt get} and {\tt put}
allow the programmer to think in terms of changing state without sacrificing the advantages of
purity.

The first example, written in Racket, uses {\em delimited continuations} to create the illusion
of state. When evaluating an expression language, a continuation captures the "rest" of the
computation; it is the context in which the current expression is executed. For example, when
evaluating
\[ \ifThenElse{x < 3}{10}{20} \]
we start by computing $x < 3$. At that point, the rest of the computation,
\[ \ifThenElse{\_}{10}{20}, \]
is the continuation. In {\em Functional Abstraction of Typed Contexts},
\citet{danvy1989functional} present two operators for manipulating continuation contexts as
first-class functions in the language: {\em shift} written ``$\shift{k}{e}$'' and {\em reset}
written ``$\reset{e}$''. Reset delimits the scope of the current context---in the example above,
we implicitly wrap the whole expression in a reset. The expression ``$\shift{k}{e}$''captures the
current context as a function, $k$, and then executes $e$ in a fresh context. We can rewrite the
above computation using shift and reset and observe the way shift and reset are interpreted.
\begin{align*}
  & \reset{\ifThenElse{(\shift{k}{k~(x < 3)})}{10}{20}} \\
  \rightarrow\ & \letIn{k}{(\lambdaE{b}{\ifThenElse{b}{10}{20}})}{k~(x < 3)}
\end{align*}
Reset delimits the context, in this case the whole ``$\textsf{if}$'' expression, and shift packages
the continuation into the variable $k$ before immediately applying it. Since shift just applies it's
continuation nothing has changed---the result will be the same as the expression above---but there
is no reason for the shift body to be so simple. Clever uses of delimited continuations can build up
complex control flow including implementing the state abstraction from our original example.

The second example simulates stateful computations using a {\em monad} in Haskell. Monads were
introduced to the programming languages literature by \citet{moggi1991notions}, but they were
popularized by \citeauthor{wadler1990comprehending} in {\em Comprehending
Monads}~\cite{wadler1990comprehending}. As a programming abstraction, monads generalize the
well-known idea of list comprehensions:
\[
  [ (x,\,y) \mid x \leftarrow [1,\, 2] ;\ y \leftarrow [3,\, 4] ]^{\textsf{List}}
\]
In this case the monad is $\textsf{List}$ and the result is a Cartesian product of lists $[1,\,
2]$ and $[3,\, 4]$, but the syntax can be used for other monads:
\[
  [ y \mid x \leftarrow \textsf{thisMightFail}~() ;\ y \leftarrow \textsf{thisMightFailToo}~{x} ]^{\textsf{Maybe}}
\]
If either of the provided computations fail, the result of this expression will be $\nothing$,
otherwise the result will be the final result of the overall computation. There are dozens of monads
that programmers use in practice, each of which gives a different semantics to this comprehension
syntax. One such monad, the $\textsf{State}$ monad, can be used to implement our running example.

It is not immediately clear how manipulating continuations is related to re-interpreting
comprehension syntax, but clearly there is a common thread between them. Both delimited
continuations and monads can implement the state abstraction from above, non-deterministic
computations, exceptions, and other complex programming techniques. This report will explore
those commonalities in detail. I make three contributions after a brief discussion of common
notation (\S \ref{sec:notation}):
\begin{itemize}
  \item I summarize and re-contextualize two influential papers: {\em A Functional Abstraction of
    Typed Contexts} by \citeauthor{danvy1989functional} (\S \ref{sec:danvy}) and {\em Comprehending
    Monads} by \citeauthor{wadler1990comprehending} (\S \ref{sec:wadler}).\footnote{This is a
    requirement of the WPE-II exam, but I hope that reformulating these results will still be
    instructive.}
  \item I show the many ways in which delimited continuations can implement common monadic
    abstractions and conversely show that continuations can be captured as a monad
    (\S \ref{sec:programming}).
  \item I explore a fascinating meta-theoretic observation: by performing a monad-agnostic
    transformation given by Wadler we can recover the extended continuation passing style
    transformation presented by Danvy (\S \ref{sec:metatheory}).
\end{itemize}
I conclude with some remarks on the broader context in which these abstractions exist
(\ref{sec:conclusion}).

\section{Notes on Notation} \label{sec:notation}

\outline{
\begin{itemize}
  \item Racket and Haskell for examples
  \item Delimited Continuations: {\tt shift k in e} vs $\xi k.\,e$, {\tt reset e} vs $\langle e \rangle$
  \item Monads: join vs. bind vs. comprehensions.
    $x \leftarrow e_1 ;\!; e_2 \equiv \textsf{bind}~e_1~(\lambda x.\, e_2)$
  \item Assume a base, simply-typed lambda calculus
\end{itemize}
}

\section{{\em A Functional Abstraction of Typed Contexts}} \label{sec:danvy}

\section{{\em Comprehending Monads}} \label{sec:wadler}

\section{Programming Overlap} \label{sec:programming}

\section{Meta-Theory} \label{sec:metatheory}

\section{Conclusion} \label{sec:conclusion}

\begin{acks}
\end{acks}

\bibliography{references}
\bibliographystyle{plainnat}

\end{document}

% \begin{quote}
%   [In some languages,] it may be possible to jump out of an expression and then later jump back
%   into it again and resume the process of evaluation. Continuations are sufficiently powerful to
%   deal with such a situation. (This could not be taken to imply approval of jumps back into
%   expressions as a language design feature—but if a language can specify something, however odd,
%   the method used to give its formal semantics must be powerful enough to describe it.)
%   \cite{strachey2000continuations}
% \end{quote}
